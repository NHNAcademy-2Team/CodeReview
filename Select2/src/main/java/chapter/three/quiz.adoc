제3장에 대한 프로그래밍 연습문제

이 페이지에는 본 교재 제3장에 관한 몇 가지 연습문제들이 포함되어 있다. 각 연습문제에 대해 가능한 해답에 대한 링크가 제공된다. 각 해답에는 프로그래머가 문제에 어떻게 접근할 수 있는지에 대한 논의와 문제나 그 해답에 의해 제기된 흥미로운 점, 그리고 해답의 완전한 소스 코드에 대한 논의가 포함되어 있다.

연습 3.1:

주사위 한 쌍을 몇 번이나 굴려야 뱀의 눈(snake eyes)이 뜰까? 주사위를 손으로 굴려서 실험을 할 수도 있을 것이다. 해당 실험을 시뮬레이션하는 컴퓨터 프로그램을 작성하라. 이 프로그램은 주사위가 뱀의 눈으로 나타나기 전까지 시행된 굴림 횟수(the number of rolls)를 보고해야 한다. (주: "뱀의 눈"은 두 주사위가 모두 1의 값을 보임을 의미한다.) 연습문제 2.2에서 주사위 한 쌍에 관한 굴리기 시뮬레이션 방법을 설명했다.

연습 3.2:

1과 10000 사이의 정수 중 어느 정수가 가장 많은 수의 약수들을 가지고 있는가, 그리고 그 정수는 몇 개의 약수들을 가지는가? 프로그램을 작성하여 해답을 찾고 결과를 출력하라. 이 범위의 여러 정수들은 약수들의 최대 갯수가 동일할 수 있다. 프로그램은 이들 중 하나만 출력해야 한다. 제3장 제4절 제2관의 예제에서 약수에 대해 논의하였다. 해당 예제의 소스 코드는 CountDivisors.java이다.

최대값을 찾는 방법에 대한 힌트가 필요할 수 있다. 기본적인 아이디어는 지금까지 살펴본 약수들의 가장 큰 수를 추적하면서 모든 정수를 살펴보는 것이다. 또한, 해당되는 갯수의 약수들을 지닌 정수를 계속 추적하라.

연습 3.3:

17 + 3 및 3.14159 * 4.7과 같은 간단한 표현식을 평가할 프로그램을 작성하라. 표현식은 사용자에 의해 입력되어야 한다. 입력은 항상 숫자와 이에 이어지는 연산자, 그리고 다른 숫자로 구성된다. 허용되는 연산자는 +, -, * 및 /이다. 숫자는 TextIO.getDouble()로, 연산자는 TextIO.getChar()로 읽을 수 있다. 프로그램은 표현식을 읽고, 값을 인쇄하고, 다른 표현식을 읽고, 값을 인쇄하는 등의 작업을 해야 한다. 사용자가 행의 첫 번째 번호로 0을 입력하면 프로그램은 종료되어야 한다.

연습 3.4:

입력 텍스트 한 줄을 읽고 이를 단어로 나누는 프로그램을 작성하라. 단어들은 한 줄에 하나씩 출력되어야 한다. 단어는 일련의 글자들(letters)로 정의된다. 입력에서 글자가 아닌 문자들은 모두 폐기되어야 한다. 예를 들어, 사용자가 다음 행을 입력하는 경우:

He said, "That's not a good idea."
해당 프로그램의 출력은 다음과 같아야 한다:

He
said
That
s
not
a
good
idea
해당 프로그램의 개선된 버전은 "that's"를 하나의 단어로 나열할 것이다. 소유격 부호(apostrophe)의 양쪽에 글자가 있는 경우 부호는 단어의 일부로 간주할 수 있다.

어떤 문자가 글자인지 테스트하기 위해 (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')를 사용할 수 있다. 하지만 이는 영어 및 이와 유사한 언어에서만 통하는 방식이다. 좀 더 좋은 선택은 표준 함수인 Character.isLetter(ch)를 호출하는 것인데, 이는 ch가 글자일 경우 true, 그렇지 않을 경우에는 false로 부울 값을 반환한다. 즉 모든 유니코드 문자에 적용된다.

연습 3.5:

여러 도시에 있는 회사의 매출 수치에 대한 정보가 파일에 포함되어 있다고 가정한다. 파일의 각 줄에는 도시 이름이 들어 있고, 그 뒤를 콜론(:)이 따르며, 해당 도시에 대한 데이터가 뒤따른다. 데이터는 double 자료형의 숫자이다. 그러나 일부 도시의 경우 사용할 데이터가 없다. 이러한 줄에서 데이터는 데이터가 누락된 이유를 설명하는 말로 대체된다. 예를 들어 파일의 여러 행은 다음과 같이 보일 수 있다:

San Francisco:  19887.32
Chicago:  no report received
New York: 298734.12
모든 도시의 총 매출을 계산하고 인쇄할 프로그램을 작성하라. 이 프로그램은 또한 데이터가 제공되지 않은 도시의 갯수를 보고해야 한다. 파일의 이름은 "sales.dat"이다.

이 프로그램을 완료하려면 제2장 제4절 제4관에서 다루지 않았던, TextIO 를 이용한 파일 입력에 대한 한 가지 사항이 필요하다. 파일 안에 줄이 몇 개 있는지를 미리 모르기 때문에, 파일 끝에 언제 도착했는지를 알 수 있는 방법이 필요하다. TextIO 가 파일에서 읽을 때, TextIO.eof()를 사용하여 파일의 끝(end of file)을 테스트할 수 있다. 이 부울 값 함수는 파일이 완전히 읽히면 true를 반환하고, 파일에 읽을 데이터가 더 있으면 false를 반환한다. 이는 while (TextIO.eof() == false)...을 만족하는 동안 파일의 줄을 루프에서 읽을 수 있다는 것을 의미한다. 파일의 모든 행을 읽으면 루프가 종료될 것이다.

제안: 각 줄에 대하여, 이를 읽고 콜론까지의 문자를 무시하라. 그런 다음 나머지 줄을 String 자료형의 변수로 읽어보라. 문자열을 숫자로 변환하려 시도하고, try..catch를 사용하여 변환이 성공했는지 여부를 테스트하라.

연습 3.6:

연습 3.2는 약수들의 수가 가장 많은 1에서 10000 사이의 숫자를 찾도록 하였다. 그러한 숫자 하나만을 출력했어야 하였다. 약수들의 갯수를 가장 많이 가진 수들 전체를 출력하도록 해당 프로그램을 수정하라. 다음과 같은 배열을 사용하라: 각 숫자에 대한 약수들을 셀 때 각각의 갯수를 배열로 저장하라. 그런 다음 프로그램이 끝나면 배열을 거쳐 최대의 갯수가 있는 숫자를 모두 출력할 수 있다. 프로그램의 출력은 다음과 같이 보여야 한다:

1과 10000 사이의 정수 중에서,
약수의 최대 갯수는 64
이러한 약수의 갯수를 가진 숫자들은:
   7560
   9240
연습 3.7:

제3장 제8절 제3관의 예제는 "중복된 생일을 찾기 전까지 몇 명의 무작위한 사람들을 선택해야 하는가?"라는 질문에 답하려고 했다. 그 프로그램의 소스 코드는 BirthdayProblem.java 파일에서 찾을 수 있다. 다음은 몇몇 관련 의문점들이다:

생일이 같은 세 사람을 찾으려면 무작위로 몇 명을 뽑아야 하는가? (즉, 세 사람 모두 같은 달 같은 날에 태어났지만 반드시 같은 해에 태어난 것은 아니다.)
365명을 무작위로 선택한다고 가정하자. 그들은 다른 생일들을 얼마나 가질 것인가? (이 숫자는 이론적으로 1에서 365까지일 수 있다.)
한 해의 365일 각각마다 생일이 있는 사람을 적어도 한 명 찾으려면 얼마나 많은 다른 사람을 확인해야 하는가?
이 질문들에 답하기 위해 세 개의 프로그램을 작성하라. 각 프로그램은 무작위로 사람을 고르고 그들의 생일을 확인하는 시뮬레이션을 해야 한다. (각각의 경우 윤년의 가능성은 무시한다.)

